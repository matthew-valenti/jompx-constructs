"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CdkPipeline = void 0;
const cdk = require("aws-cdk-lib");
const codebuild = require("aws-cdk-lib/aws-codebuild");
const iam = require("aws-cdk-lib/aws-iam");
const s3 = require("aws-cdk-lib/aws-s3");
const pipelines = require("aws-cdk-lib/pipelines");
// eslint-disable-next-line import/no-extraneous-dependencies
const changeCase = require("change-case");
const constructs_1 = require("constructs");
const config_1 = require("../config/config");
/**
 * Continuous integration and delivery (CI/CD) using CDK Pipelines:
 * https://docs.aws.amazon.com/cdk/v2/guide/cdk_pipeline.html
 * https://docs.aws.amazon.com/cdk/api/v2/docs/aws-cdk-lib.pipelines-readme.html
 * https://docs.aws.amazon.com/cdk/api/v2/docs/aws-cdk-lib.aws_codebuild-readme.html
 *
 * Build Spec Reference: https://docs.aws.amazon.com/codebuild/latest/userguide/build-spec-ref.html
 *
 * TODO: nx affected:
 * https://nx.dev/ci/monorepo-ci-circle-ci
 *
 *  * TODO deploy in parallel:
 * https://docs.aws.amazon.com/cdk/api/v1/docs/pipelines-readme.html
 *
 * TODO: Trigger apps pipeline
 * https://stackoverflow.com/questions/62857925/how-to-invoke-a-pipeline-based-on-another-pipeline-success-using-aws-codecommit
 *
 * Create CDK pipelines that deploy CDK code across AWS accounts on GitHub branch updates.
 * All CDK pipeline resources reside on a single AWS account (preferrably a dedicated CICD AWS account)
 * This dedicated AWS account will have permissions to deploy to all other accounts (as needed). Developers can also be given admin or readonly permissions to troubleshoot CDK deployment errors.
 * Allow for both test and prod CICD AWS accounts. CICD enhancements can be done safely on the test CICD AWS account without affecting production deployments.
 * Create a CDK pipeline for each stage (e.g. sandbox1, test, prod) where each stage is an AWS account (e.g. prod resources reside on a prod AWS account).
 * Each stage is compromised of a set of "CDK stages" which can be deployed to any account. This allows common CDK resources to be deployed to a common AWS account (e.g. AWS wAF can be deployed to a common AWS account and shared across stages sandbox1, test, prod).
 * A github branch update will trigger a CDK pipeline to start.
 * Each stage is associated with a branch (e.g. updates to the main branch triggers the prod pipeline to start, updates to the sandbox1 branch triggers the sandbox1 pipelien to start).
 * An CDK stages is comprised or one or more CDK stacks.
 * Developers can also manually deploy stacks (if they have the appropriate AWS account permissions setup on their local).
 * During development, developers will typically manually deploy a stack they're working on to their sandbox AWS account.
 * A manual deployment of the CDK pipeline stack is needed to the test and prod CICD AWS accounts.
 * Supports configuration to allow a company to have any number of stages, accounts, and CDK stages.
 * The CICD test AWS account listens to branches with test in the branch name. It's important that test pipelines don't trigger on commits to main, test, sandbox1, etc.
 *
 * AWS CodePipeline recommends using a CodePipelineSource connection to securly connect to GitHub. However, CodeBuild only supports the old Github token authorization.
 * Stage branches use a connection. Regex stage branches use a token.
 * Setup steps are required to enable both a connection and a token.
 *
 * GitHub has a 20 web hook limit per event (per repo). It may be necessary to switch from web hook to polling or not create unused code pipelines (e.g. test-sandbox1 branch deploys may not be needed).
 *
 * AWS Docs: The pipeline is self-mutating, which means that if you add new application stages in the source code, or new stacks to MyApplication, the pipeline will automatically reconfigure itself to deploy those new stages and stacks.
 *
 * Important:
 * - The CDK pipeline acts in the context of a stage (e.g. sandbox1, test, prod) and a stage is typically associated with one AWS account (e.g. prod AWS account).
 * - A stage parameter must always be available. This parameter can be specified on the command line (which always takes precedence) or from a config file.
 * - The cdk synth command in the pipeline includes a stage param. When the pipeline runs, the stage param is available in our CDK code.
 * e.g. When the main branch is updated, it triggers the prod pipeline to synth and deploy CDK changes with stage param = 'prod'. This allows developers to write conditional CDK code e.g. if (status === 'prod').
 * - A CDK pipeline is connected to one GitHub branch (and listens to that branch for updates).
 *
 * Deployments supported:
 * - Manual CDK Pipeline stack deployment to CICD test and prod environments.
 * - GitHub triggered deployments across all branches and all CICD stage branches e.g. (prod & test-prod, test & test-test, sandbox1 & test-sandbox1).
 * - Manual CDK stack deploys (to any env). e.g. deploy stack to sandbox1, deploy stack to test, deploy stack to prod.
 */
class CdkPipeline extends constructs_1.Construct {
    constructor(scope, id, props) {
        var _a, _b;
        super(scope, id);
        this.environmentPipelines = [];
        const config = new config_1.Config(this.node);
        const commands = ['npm install', 'npm -g install typescript', 'npm install -g nx', 'nx build cdk', 'nx synth cdk --args="--quiet --context stage=$STAGE"']; // AWS docs example commands: ['npm ci', 'npm run build', 'npx cdk synth']
        const primaryOutputDirectory = 'apps/cdk/cdk.out';
        const stages = new Map(Object.entries(config.stages()));
        const branchStages = new Map([...stages].filter(([_, v]) => v.branch && !v.branch.startsWith('(') && !v.branch.endsWith(')')));
        const branchRegexStages = new Map([...stages].filter(([_, v]) => v.branch && v.branch.startsWith('(') && v.branch.endsWith(')')));
        // For static branches e.g. main, test.
        for (const [stage, stageValue] of branchStages.entries()) {
            // If CICD prod pipelines then use branch names in config. Else CICD stage is test or other so use stage+branch e.g. test-prod, test-test
            const branch = (props.stage === 'prod') ? stageValue.branch : `${props.stage}-${stageValue.branch}`;
            // create a standard cdk pipeline for static branches. Performance is better (no S3 file copy required).
            const pipeline = new pipelines.CodePipeline(this, `CdkCodePipeline${changeCase.pascalCase(branch)}`, {
                pipelineName: `cdk-pipeline-${branch}`,
                crossAccountKeys: true,
                synth: new pipelines.ShellStep('Synth', {
                    env: {
                        STAGE: `${props.stage}` // The CICD stage: typically test or prod.
                    },
                    // TODO: Allow GitHub token option.
                    // input: pipelines.CodePipelineSource.gitHub(
                    //     `${props.gitHub.owner}/${props.gitHub.repo}`,
                    //     branch,
                    //     { authentication: props.gitHub.token }
                    // ),
                    input: pipelines.CodePipelineSource.connection(`${props.gitHub.owner}/${props.gitHub.repo}`, branch, {
                        connectionArn: props.gitHub.connectionArn,
                        codeBuildCloneOutput: true
                    }),
                    commands: (_a = props.commands) !== null && _a !== void 0 ? _a : commands,
                    primaryOutputDirectory
                })
            });
            this.environmentPipelines.push({ branch, pipelineStage: stage, pipeline });
        }
        if (branchRegexStages.size) {
            // Create bucket to save github sandbox feature branch files (as zip).
            const bucket = new s3.Bucket(this, `${config.organizationNamePascalCase()}CdkPipelineBranch`, {
                // Version must be true to use as CodePipeline source.
                versioned: true,
                publicReadAccess: false,
                blockPublicAccess: s3.BlockPublicAccess.BLOCK_ALL,
                enforceSSL: true,
                // Destroy bucket on stack delete. Bucket contains temporary copy of source control files only.
                removalPolicy: cdk.RemovalPolicy.DESTROY,
                // Delete all bucket objects on bucket/stack destroy.
                autoDeleteObjects: true
            });
            for (const [stage, stageValue] of branchRegexStages.entries()) {
                const branchSubstring = stageValue.branch.slice(1, -1); // Remove first and last chars i.e. parenthesis.
                const branchFileName = `branch-${props.stage}-${branchSubstring}.zip`;
                const stagePascalCase = changeCase.pascalCase(stage);
                // If CICD stage is prod, match branch substring somewhere in branch name. Else CICD stage is 'test' (or other) so match 'test' somewhere in branch name.
                // e.g. prod: (sandbox1) in config will match branches: sandbox1, my-sandbox1-feature, my-sandbox1-feature2
                // e.g. test: e.g. (sandbox1) in config will match: testsandbox1, sandbox1test, test-sandbox1, sandbox1-test, etc.
                const branchRegex = (props.stage === 'prod') ? `(${branchSubstring})` : `(?=.*${branchSubstring})(?=.*test)`;
                // Create github source (e.g. sandbox feature branch).
                const gitHubBranchSource = codebuild
                    .Source.gitHub({
                    owner: props.gitHub.owner,
                    repo: props.gitHub.repo,
                    fetchSubmodules: true,
                    webhook: true,
                    webhookFilters: [
                        codebuild.FilterGroup
                            .inEventOf(codebuild.EventAction.PUSH)
                            .andBranchIsNot('main') // For additional protection only.
                            .andBranchIs(`.*${branchRegex}.*`) // e.g. author-sandbox1-my-feature, test = author-test-sandbox1-my-feature
                    ]
                });
                // Create build project (to copy feature branch files to S3 on github push).
                const githubCodeBuildProject = new codebuild.Project(this, `GithubCodeBuildProject${stagePascalCase}`, {
                    projectName: `copy-github-${props.stage}-${branchSubstring}-to-s3`,
                    buildSpec: codebuild.BuildSpec.fromObject({
                        version: 0.2,
                        artifacts: {
                            files: '**/*'
                        }
                    }),
                    source: gitHubBranchSource,
                    artifacts: codebuild.Artifacts.s3({
                        name: branchFileName,
                        bucket,
                        includeBuildId: false,
                        packageZip: true,
                        identifier: 'GithubArtifact'
                    })
                });
                // CodeBuild project requires permissions to S3 bucket objects.
                githubCodeBuildProject.addToRolePolicy(new iam.PolicyStatement({
                    effect: iam.Effect.ALLOW,
                    actions: ['s3:ListBucket', 's3:GetObject', 's3:PutObject', 's3:DeleteObject'],
                    resources: [
                        bucket.bucketArn,
                        `${bucket.bucketArn}/*`
                    ]
                }));
                const pipeline = new pipelines.CodePipeline(this, `CdkCodePipeline${stagePascalCase}`, {
                    pipelineName: `cdk-pipeline-${props.stage}-${branchSubstring}`,
                    crossAccountKeys: true,
                    synth: new pipelines.ShellStep('Synth', {
                        env: {
                            STAGE: props.stage // The CICD stage typically: test or prod.
                        },
                        input: pipelines.CodePipelineSource.s3(bucket, branchFileName),
                        commands: (_b = props.commands) !== null && _b !== void 0 ? _b : commands,
                        primaryOutputDirectory
                    })
                });
                // The branch name is actually a regex. But specify a branch naem that's easier to work with (and still matches the regex) e.g. test-sandbox1.
                const branch = (props.stage === 'prod') ? branchSubstring : `${props.stage}-${branchSubstring}`;
                this.environmentPipelines.push({ branch, pipelineStage: stage, pipeline });
            }
        }
    }
}
exports.CdkPipeline = CdkPipeline;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2RrLXBpcGVsaW5lLmNvbnN0cnVjdC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9waXBlbGluZS9jZGstcGlwZWxpbmUuY29uc3RydWN0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLG1DQUFtQztBQUNuQyx1REFBdUQ7QUFDdkQsMkNBQTJDO0FBQzNDLHlDQUF5QztBQUN6QyxtREFBbUQ7QUFDbkQsNkRBQTZEO0FBQzdELDBDQUEwQztBQUMxQywyQ0FBdUM7QUFDdkMsNkNBQTBDO0FBd0IxQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBbURHO0FBQ0gsTUFBYSxXQUFZLFNBQVEsc0JBQVM7SUFJdEMsWUFBWSxLQUFnQixFQUFFLEVBQVUsRUFBRSxLQUF3Qjs7UUFDOUQsS0FBSyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsQ0FBQztRQUhkLHlCQUFvQixHQUEyQixFQUFFLENBQUM7UUFLckQsTUFBTSxNQUFNLEdBQUcsSUFBSSxlQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3JDLE1BQU0sUUFBUSxHQUFHLENBQUMsYUFBYSxFQUFFLDJCQUEyQixFQUFFLG1CQUFtQixFQUFFLGNBQWMsRUFBRSxzREFBc0QsQ0FBQyxDQUFDLENBQUMsMEVBQTBFO1FBQ3RPLE1BQU0sc0JBQXNCLEdBQUcsa0JBQWtCLENBQUM7UUFFbEQsTUFBTSxNQUFNLEdBQUcsSUFBSSxHQUFHLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsTUFBTSxFQUFHLENBQUMsQ0FBQyxDQUFDO1FBQ3pELE1BQU0sWUFBWSxHQUFHLElBQUksR0FBRyxDQUFDLENBQUMsR0FBRyxNQUFNLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLE1BQU0sSUFBSSxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQy9ILE1BQU0saUJBQWlCLEdBQUcsSUFBSSxHQUFHLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsTUFBTSxJQUFJLENBQUMsQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUVsSSx1Q0FBdUM7UUFDdkMsS0FBSyxNQUFNLENBQUMsS0FBSyxFQUFFLFVBQVUsQ0FBQyxJQUFJLFlBQVksQ0FBQyxPQUFPLEVBQUUsRUFBRTtZQUV0RCx5SUFBeUk7WUFDekksTUFBTSxNQUFNLEdBQUcsQ0FBQyxLQUFLLENBQUMsS0FBSyxLQUFLLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxLQUFLLElBQUksVUFBVSxDQUFDLE1BQU0sRUFBRSxDQUFDO1lBRXBHLHdHQUF3RztZQUN4RyxNQUFNLFFBQVEsR0FBRyxJQUFJLFNBQVMsQ0FBQyxZQUFZLENBQUMsSUFBSSxFQUFFLGtCQUFrQixVQUFVLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUU7Z0JBQ2pHLFlBQVksRUFBRSxnQkFBZ0IsTUFBTSxFQUFFO2dCQUN0QyxnQkFBZ0IsRUFBRSxJQUFJO2dCQUN0QixLQUFLLEVBQUUsSUFBSSxTQUFTLENBQUMsU0FBUyxDQUFDLE9BQU8sRUFBRTtvQkFDcEMsR0FBRyxFQUFFO3dCQUNELEtBQUssRUFBRSxHQUFHLEtBQUssQ0FBQyxLQUFLLEVBQUUsQ0FBQywwQ0FBMEM7cUJBQ3JFO29CQUNELG1DQUFtQztvQkFDbkMsOENBQThDO29CQUM5QyxvREFBb0Q7b0JBQ3BELGNBQWM7b0JBQ2QsNkNBQTZDO29CQUM3QyxLQUFLO29CQUNMLEtBQUssRUFBRSxTQUFTLENBQUMsa0JBQWtCLENBQUMsVUFBVSxDQUFDLEdBQUcsS0FBSyxDQUFDLE1BQU0sQ0FBQyxLQUFLLElBQUksS0FBSyxDQUFDLE1BQU0sQ0FBQyxJQUFJLEVBQUUsRUFBRSxNQUFNLEVBQUU7d0JBQ2pHLGFBQWEsRUFBRSxLQUFLLENBQUMsTUFBTSxDQUFDLGFBQWE7d0JBQ3pDLG9CQUFvQixFQUFFLElBQUk7cUJBQzdCLENBQUM7b0JBQ0YsUUFBUSxRQUFFLEtBQUssQ0FBQyxRQUFRLG1DQUFJLFFBQVE7b0JBQ3BDLHNCQUFzQjtpQkFDekIsQ0FBQzthQUNMLENBQUMsQ0FBQztZQUVILElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxJQUFJLENBQUMsRUFBRSxNQUFNLEVBQUUsYUFBYSxFQUFFLEtBQUssRUFBRSxRQUFRLEVBQUUsQ0FBQyxDQUFDO1NBQzlFO1FBRUQsSUFBSSxpQkFBaUIsQ0FBQyxJQUFJLEVBQUU7WUFDeEIsc0VBQXNFO1lBQ3RFLE1BQU0sTUFBTSxHQUFHLElBQUksRUFBRSxDQUFDLE1BQU0sQ0FBQyxJQUFJLEVBQUUsR0FBRyxNQUFNLENBQUMsMEJBQTBCLEVBQUUsbUJBQW1CLEVBQUU7Z0JBQzFGLHNEQUFzRDtnQkFDdEQsU0FBUyxFQUFFLElBQUk7Z0JBQ2YsZ0JBQWdCLEVBQUUsS0FBSztnQkFDdkIsaUJBQWlCLEVBQUUsRUFBRSxDQUFDLGlCQUFpQixDQUFDLFNBQVM7Z0JBQ2pELFVBQVUsRUFBRSxJQUFJO2dCQUNoQiwrRkFBK0Y7Z0JBQy9GLGFBQWEsRUFBRSxHQUFHLENBQUMsYUFBYSxDQUFDLE9BQU87Z0JBQ3hDLHFEQUFxRDtnQkFDckQsaUJBQWlCLEVBQUUsSUFBSTthQUMxQixDQUFDLENBQUM7WUFFSCxLQUFLLE1BQU0sQ0FBQyxLQUFLLEVBQUUsVUFBVSxDQUFDLElBQUksaUJBQWlCLENBQUMsT0FBTyxFQUFFLEVBQUU7Z0JBRTNELE1BQU0sZUFBZSxHQUFHLFVBQVUsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsZ0RBQWdEO2dCQUN4RyxNQUFNLGNBQWMsR0FBRyxVQUFVLEtBQUssQ0FBQyxLQUFLLElBQUksZUFBZSxNQUFNLENBQUM7Z0JBQ3RFLE1BQU0sZUFBZSxHQUFHLFVBQVUsQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLENBQUM7Z0JBRXJELHlKQUF5SjtnQkFDekosMkdBQTJHO2dCQUMzRyxrSEFBa0g7Z0JBQ2xILE1BQU0sV0FBVyxHQUFHLENBQUMsS0FBSyxDQUFDLEtBQUssS0FBSyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxlQUFlLEdBQUcsQ0FBQyxDQUFDLENBQUMsUUFBUSxlQUFlLGFBQWEsQ0FBQztnQkFFN0csc0RBQXNEO2dCQUN0RCxNQUFNLGtCQUFrQixHQUFHLFNBQVM7cUJBQy9CLE1BQU0sQ0FBQyxNQUFNLENBQUM7b0JBQ1gsS0FBSyxFQUFFLEtBQUssQ0FBQyxNQUFNLENBQUMsS0FBSztvQkFDekIsSUFBSSxFQUFFLEtBQUssQ0FBQyxNQUFNLENBQUMsSUFBSTtvQkFDdkIsZUFBZSxFQUFFLElBQUk7b0JBQ3JCLE9BQU8sRUFBRSxJQUFJO29CQUNiLGNBQWMsRUFBRTt3QkFDWixTQUFTLENBQUMsV0FBVzs2QkFDaEIsU0FBUyxDQUFDLFNBQVMsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDOzZCQUNyQyxjQUFjLENBQUMsTUFBTSxDQUFDLENBQUMsa0NBQWtDOzZCQUN6RCxXQUFXLENBQUMsS0FBSyxXQUFXLElBQUksQ0FBQyxDQUFDLDBFQUEwRTtxQkFDcEg7aUJBQ0osQ0FBQyxDQUFDO2dCQUVQLDRFQUE0RTtnQkFDNUUsTUFBTSxzQkFBc0IsR0FBRyxJQUFJLFNBQVMsQ0FBQyxPQUFPLENBQUMsSUFBSSxFQUFFLHlCQUF5QixlQUFlLEVBQUUsRUFBRTtvQkFDbkcsV0FBVyxFQUFFLGVBQWUsS0FBSyxDQUFDLEtBQUssSUFBSSxlQUFlLFFBQVE7b0JBQ2xFLFNBQVMsRUFBRSxTQUFTLENBQUMsU0FBUyxDQUFDLFVBQVUsQ0FBQzt3QkFDdEMsT0FBTyxFQUFFLEdBQUc7d0JBQ1osU0FBUyxFQUFFOzRCQUNQLEtBQUssRUFBRSxNQUFNO3lCQUNoQjtxQkFDSixDQUFDO29CQUNGLE1BQU0sRUFBRSxrQkFBa0I7b0JBQzFCLFNBQVMsRUFBRSxTQUFTLENBQUMsU0FBUyxDQUFDLEVBQUUsQ0FBQzt3QkFDOUIsSUFBSSxFQUFFLGNBQWM7d0JBQ3BCLE1BQU07d0JBQ04sY0FBYyxFQUFFLEtBQUs7d0JBQ3JCLFVBQVUsRUFBRSxJQUFJO3dCQUNoQixVQUFVLEVBQUUsZ0JBQWdCO3FCQUMvQixDQUFDO2lCQUNMLENBQUMsQ0FBQztnQkFDSCwrREFBK0Q7Z0JBQy9ELHNCQUFzQixDQUFDLGVBQWUsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxlQUFlLENBQUM7b0JBQzNELE1BQU0sRUFBRSxHQUFHLENBQUMsTUFBTSxDQUFDLEtBQUs7b0JBQ3hCLE9BQU8sRUFBRSxDQUFDLGVBQWUsRUFBRSxjQUFjLEVBQUUsY0FBYyxFQUFFLGlCQUFpQixDQUFDO29CQUM3RSxTQUFTLEVBQUU7d0JBQ1AsTUFBTSxDQUFDLFNBQVM7d0JBQ2hCLEdBQUcsTUFBTSxDQUFDLFNBQVMsSUFBSTtxQkFDMUI7aUJBQ0osQ0FBQyxDQUFDLENBQUM7Z0JBRUosTUFBTSxRQUFRLEdBQUcsSUFBSSxTQUFTLENBQUMsWUFBWSxDQUFDLElBQUksRUFBRSxrQkFBa0IsZUFBZSxFQUFFLEVBQUU7b0JBQ25GLFlBQVksRUFBRSxnQkFBZ0IsS0FBSyxDQUFDLEtBQUssSUFBSSxlQUFlLEVBQUU7b0JBQzlELGdCQUFnQixFQUFFLElBQUk7b0JBQ3RCLEtBQUssRUFBRSxJQUFJLFNBQVMsQ0FBQyxTQUFTLENBQUMsT0FBTyxFQUFFO3dCQUNwQyxHQUFHLEVBQUU7NEJBQ0QsS0FBSyxFQUFFLEtBQUssQ0FBQyxLQUFLLENBQUMsMENBQTBDO3lCQUNoRTt3QkFDRCxLQUFLLEVBQUUsU0FBUyxDQUFDLGtCQUFrQixDQUFDLEVBQUUsQ0FBQyxNQUFNLEVBQUUsY0FBYyxDQUFDO3dCQUM5RCxRQUFRLFFBQUUsS0FBSyxDQUFDLFFBQVEsbUNBQUksUUFBUTt3QkFDcEMsc0JBQXNCO3FCQUN6QixDQUFDO2lCQUNMLENBQUMsQ0FBQztnQkFFSCw4SUFBOEk7Z0JBQzlJLE1BQU0sTUFBTSxHQUFHLENBQUMsS0FBSyxDQUFDLEtBQUssS0FBSyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsZUFBZSxDQUFDLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxLQUFLLElBQUksZUFBZSxFQUFFLENBQUM7Z0JBQ2hHLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxJQUFJLENBQUMsRUFBRSxNQUFNLEVBQUUsYUFBYSxFQUFFLEtBQUssRUFBRSxRQUFRLEVBQUUsQ0FBQyxDQUFDO2FBQzlFO1NBQ0o7SUFDTCxDQUFDO0NBQ0o7QUF0SUQsa0NBc0lDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgY2RrIGZyb20gJ2F3cy1jZGstbGliJztcclxuaW1wb3J0ICogYXMgY29kZWJ1aWxkIGZyb20gJ2F3cy1jZGstbGliL2F3cy1jb2RlYnVpbGQnO1xyXG5pbXBvcnQgKiBhcyBpYW0gZnJvbSAnYXdzLWNkay1saWIvYXdzLWlhbSc7XHJcbmltcG9ydCAqIGFzIHMzIGZyb20gJ2F3cy1jZGstbGliL2F3cy1zMyc7XHJcbmltcG9ydCAqIGFzIHBpcGVsaW5lcyBmcm9tICdhd3MtY2RrLWxpYi9waXBlbGluZXMnO1xyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLWV4dHJhbmVvdXMtZGVwZW5kZW5jaWVzXHJcbmltcG9ydCAqIGFzIGNoYW5nZUNhc2UgZnJvbSAnY2hhbmdlLWNhc2UnO1xyXG5pbXBvcnQgeyBDb25zdHJ1Y3QgfSBmcm9tICdjb25zdHJ1Y3RzJztcclxuaW1wb3J0IHsgQ29uZmlnIH0gZnJvbSAnLi4vY29uZmlnL2NvbmZpZyc7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIElDZGtQaXBlbGluZVByb3BzIHtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIENJQ0Qgc3RhZ2UuIFR5cGljYWxseSBwcm9kIG9yIHRlc3QuXHJcbiAgICAgKi9cclxuICAgIHN0YWdlOiBzdHJpbmc7XHJcbiAgICBnaXRIdWI6IElDZGtQaXBlbGluZUdpdEh1YlByb3BzO1xyXG4gICAgY29tbWFuZHM/OiBzdHJpbmdbXTtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBJQ2RrUGlwZWxpbmVHaXRIdWJQcm9wcyB7XHJcbiAgICBvd25lcjogc3RyaW5nO1xyXG4gICAgcmVwbzogc3RyaW5nO1xyXG4gICAgLy8gdG9rZW46IGNkay5TZWNyZXRWYWx1ZTsgLy8gVE9ETzogQWxsb3cgR2l0SHViIHRva2VuIG9wdGlvbi5cclxuICAgIGNvbm5lY3Rpb25Bcm46IHN0cmluZztcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBJRW52aXJvbm1lbnRQaXBlbGluZSB7XHJcbiAgICBicmFuY2g6IHN0cmluZztcclxuICAgIHBpcGVsaW5lU3RhZ2U6IHN0cmluZztcclxuICAgIHBpcGVsaW5lOiBwaXBlbGluZXMuQ29kZVBpcGVsaW5lO1xyXG59XHJcblxyXG4vKipcclxuICogQ29udGludW91cyBpbnRlZ3JhdGlvbiBhbmQgZGVsaXZlcnkgKENJL0NEKSB1c2luZyBDREsgUGlwZWxpbmVzOlxyXG4gKiBodHRwczovL2RvY3MuYXdzLmFtYXpvbi5jb20vY2RrL3YyL2d1aWRlL2Nka19waXBlbGluZS5odG1sXHJcbiAqIGh0dHBzOi8vZG9jcy5hd3MuYW1hem9uLmNvbS9jZGsvYXBpL3YyL2RvY3MvYXdzLWNkay1saWIucGlwZWxpbmVzLXJlYWRtZS5odG1sXHJcbiAqIGh0dHBzOi8vZG9jcy5hd3MuYW1hem9uLmNvbS9jZGsvYXBpL3YyL2RvY3MvYXdzLWNkay1saWIuYXdzX2NvZGVidWlsZC1yZWFkbWUuaHRtbFxyXG4gKlxyXG4gKiBCdWlsZCBTcGVjIFJlZmVyZW5jZTogaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL2NvZGVidWlsZC9sYXRlc3QvdXNlcmd1aWRlL2J1aWxkLXNwZWMtcmVmLmh0bWxcclxuICpcclxuICogVE9ETzogbnggYWZmZWN0ZWQ6XHJcbiAqIGh0dHBzOi8vbnguZGV2L2NpL21vbm9yZXBvLWNpLWNpcmNsZS1jaVxyXG4gKlxyXG4gKiAgKiBUT0RPIGRlcGxveSBpbiBwYXJhbGxlbDpcclxuICogaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL2Nkay9hcGkvdjEvZG9jcy9waXBlbGluZXMtcmVhZG1lLmh0bWxcclxuICpcclxuICogVE9ETzogVHJpZ2dlciBhcHBzIHBpcGVsaW5lXHJcbiAqIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzYyODU3OTI1L2hvdy10by1pbnZva2UtYS1waXBlbGluZS1iYXNlZC1vbi1hbm90aGVyLXBpcGVsaW5lLXN1Y2Nlc3MtdXNpbmctYXdzLWNvZGVjb21taXRcclxuICpcclxuICogQ3JlYXRlIENESyBwaXBlbGluZXMgdGhhdCBkZXBsb3kgQ0RLIGNvZGUgYWNyb3NzIEFXUyBhY2NvdW50cyBvbiBHaXRIdWIgYnJhbmNoIHVwZGF0ZXMuXHJcbiAqIEFsbCBDREsgcGlwZWxpbmUgcmVzb3VyY2VzIHJlc2lkZSBvbiBhIHNpbmdsZSBBV1MgYWNjb3VudCAocHJlZmVycmFibHkgYSBkZWRpY2F0ZWQgQ0lDRCBBV1MgYWNjb3VudClcclxuICogVGhpcyBkZWRpY2F0ZWQgQVdTIGFjY291bnQgd2lsbCBoYXZlIHBlcm1pc3Npb25zIHRvIGRlcGxveSB0byBhbGwgb3RoZXIgYWNjb3VudHMgKGFzIG5lZWRlZCkuIERldmVsb3BlcnMgY2FuIGFsc28gYmUgZ2l2ZW4gYWRtaW4gb3IgcmVhZG9ubHkgcGVybWlzc2lvbnMgdG8gdHJvdWJsZXNob290IENESyBkZXBsb3ltZW50IGVycm9ycy5cclxuICogQWxsb3cgZm9yIGJvdGggdGVzdCBhbmQgcHJvZCBDSUNEIEFXUyBhY2NvdW50cy4gQ0lDRCBlbmhhbmNlbWVudHMgY2FuIGJlIGRvbmUgc2FmZWx5IG9uIHRoZSB0ZXN0IENJQ0QgQVdTIGFjY291bnQgd2l0aG91dCBhZmZlY3RpbmcgcHJvZHVjdGlvbiBkZXBsb3ltZW50cy5cclxuICogQ3JlYXRlIGEgQ0RLIHBpcGVsaW5lIGZvciBlYWNoIHN0YWdlIChlLmcuIHNhbmRib3gxLCB0ZXN0LCBwcm9kKSB3aGVyZSBlYWNoIHN0YWdlIGlzIGFuIEFXUyBhY2NvdW50IChlLmcuIHByb2QgcmVzb3VyY2VzIHJlc2lkZSBvbiBhIHByb2QgQVdTIGFjY291bnQpLlxyXG4gKiBFYWNoIHN0YWdlIGlzIGNvbXByb21pc2VkIG9mIGEgc2V0IG9mIFwiQ0RLIHN0YWdlc1wiIHdoaWNoIGNhbiBiZSBkZXBsb3llZCB0byBhbnkgYWNjb3VudC4gVGhpcyBhbGxvd3MgY29tbW9uIENESyByZXNvdXJjZXMgdG8gYmUgZGVwbG95ZWQgdG8gYSBjb21tb24gQVdTIGFjY291bnQgKGUuZy4gQVdTIHdBRiBjYW4gYmUgZGVwbG95ZWQgdG8gYSBjb21tb24gQVdTIGFjY291bnQgYW5kIHNoYXJlZCBhY3Jvc3Mgc3RhZ2VzIHNhbmRib3gxLCB0ZXN0LCBwcm9kKS5cclxuICogQSBnaXRodWIgYnJhbmNoIHVwZGF0ZSB3aWxsIHRyaWdnZXIgYSBDREsgcGlwZWxpbmUgdG8gc3RhcnQuXHJcbiAqIEVhY2ggc3RhZ2UgaXMgYXNzb2NpYXRlZCB3aXRoIGEgYnJhbmNoIChlLmcuIHVwZGF0ZXMgdG8gdGhlIG1haW4gYnJhbmNoIHRyaWdnZXJzIHRoZSBwcm9kIHBpcGVsaW5lIHRvIHN0YXJ0LCB1cGRhdGVzIHRvIHRoZSBzYW5kYm94MSBicmFuY2ggdHJpZ2dlcnMgdGhlIHNhbmRib3gxIHBpcGVsaWVuIHRvIHN0YXJ0KS5cclxuICogQW4gQ0RLIHN0YWdlcyBpcyBjb21wcmlzZWQgb3Igb25lIG9yIG1vcmUgQ0RLIHN0YWNrcy5cclxuICogRGV2ZWxvcGVycyBjYW4gYWxzbyBtYW51YWxseSBkZXBsb3kgc3RhY2tzIChpZiB0aGV5IGhhdmUgdGhlIGFwcHJvcHJpYXRlIEFXUyBhY2NvdW50IHBlcm1pc3Npb25zIHNldHVwIG9uIHRoZWlyIGxvY2FsKS5cclxuICogRHVyaW5nIGRldmVsb3BtZW50LCBkZXZlbG9wZXJzIHdpbGwgdHlwaWNhbGx5IG1hbnVhbGx5IGRlcGxveSBhIHN0YWNrIHRoZXkncmUgd29ya2luZyBvbiB0byB0aGVpciBzYW5kYm94IEFXUyBhY2NvdW50LlxyXG4gKiBBIG1hbnVhbCBkZXBsb3ltZW50IG9mIHRoZSBDREsgcGlwZWxpbmUgc3RhY2sgaXMgbmVlZGVkIHRvIHRoZSB0ZXN0IGFuZCBwcm9kIENJQ0QgQVdTIGFjY291bnRzLlxyXG4gKiBTdXBwb3J0cyBjb25maWd1cmF0aW9uIHRvIGFsbG93IGEgY29tcGFueSB0byBoYXZlIGFueSBudW1iZXIgb2Ygc3RhZ2VzLCBhY2NvdW50cywgYW5kIENESyBzdGFnZXMuXHJcbiAqIFRoZSBDSUNEIHRlc3QgQVdTIGFjY291bnQgbGlzdGVucyB0byBicmFuY2hlcyB3aXRoIHRlc3QgaW4gdGhlIGJyYW5jaCBuYW1lLiBJdCdzIGltcG9ydGFudCB0aGF0IHRlc3QgcGlwZWxpbmVzIGRvbid0IHRyaWdnZXIgb24gY29tbWl0cyB0byBtYWluLCB0ZXN0LCBzYW5kYm94MSwgZXRjLlxyXG4gKlxyXG4gKiBBV1MgQ29kZVBpcGVsaW5lIHJlY29tbWVuZHMgdXNpbmcgYSBDb2RlUGlwZWxpbmVTb3VyY2UgY29ubmVjdGlvbiB0byBzZWN1cmx5IGNvbm5lY3QgdG8gR2l0SHViLiBIb3dldmVyLCBDb2RlQnVpbGQgb25seSBzdXBwb3J0cyB0aGUgb2xkIEdpdGh1YiB0b2tlbiBhdXRob3JpemF0aW9uLlxyXG4gKiBTdGFnZSBicmFuY2hlcyB1c2UgYSBjb25uZWN0aW9uLiBSZWdleCBzdGFnZSBicmFuY2hlcyB1c2UgYSB0b2tlbi5cclxuICogU2V0dXAgc3RlcHMgYXJlIHJlcXVpcmVkIHRvIGVuYWJsZSBib3RoIGEgY29ubmVjdGlvbiBhbmQgYSB0b2tlbi5cclxuICpcclxuICogR2l0SHViIGhhcyBhIDIwIHdlYiBob29rIGxpbWl0IHBlciBldmVudCAocGVyIHJlcG8pLiBJdCBtYXkgYmUgbmVjZXNzYXJ5IHRvIHN3aXRjaCBmcm9tIHdlYiBob29rIHRvIHBvbGxpbmcgb3Igbm90IGNyZWF0ZSB1bnVzZWQgY29kZSBwaXBlbGluZXMgKGUuZy4gdGVzdC1zYW5kYm94MSBicmFuY2ggZGVwbG95cyBtYXkgbm90IGJlIG5lZWRlZCkuXHJcbiAqXHJcbiAqIEFXUyBEb2NzOiBUaGUgcGlwZWxpbmUgaXMgc2VsZi1tdXRhdGluZywgd2hpY2ggbWVhbnMgdGhhdCBpZiB5b3UgYWRkIG5ldyBhcHBsaWNhdGlvbiBzdGFnZXMgaW4gdGhlIHNvdXJjZSBjb2RlLCBvciBuZXcgc3RhY2tzIHRvIE15QXBwbGljYXRpb24sIHRoZSBwaXBlbGluZSB3aWxsIGF1dG9tYXRpY2FsbHkgcmVjb25maWd1cmUgaXRzZWxmIHRvIGRlcGxveSB0aG9zZSBuZXcgc3RhZ2VzIGFuZCBzdGFja3MuXHJcbiAqXHJcbiAqIEltcG9ydGFudDpcclxuICogLSBUaGUgQ0RLIHBpcGVsaW5lIGFjdHMgaW4gdGhlIGNvbnRleHQgb2YgYSBzdGFnZSAoZS5nLiBzYW5kYm94MSwgdGVzdCwgcHJvZCkgYW5kIGEgc3RhZ2UgaXMgdHlwaWNhbGx5IGFzc29jaWF0ZWQgd2l0aCBvbmUgQVdTIGFjY291bnQgKGUuZy4gcHJvZCBBV1MgYWNjb3VudCkuXHJcbiAqIC0gQSBzdGFnZSBwYXJhbWV0ZXIgbXVzdCBhbHdheXMgYmUgYXZhaWxhYmxlLiBUaGlzIHBhcmFtZXRlciBjYW4gYmUgc3BlY2lmaWVkIG9uIHRoZSBjb21tYW5kIGxpbmUgKHdoaWNoIGFsd2F5cyB0YWtlcyBwcmVjZWRlbmNlKSBvciBmcm9tIGEgY29uZmlnIGZpbGUuXHJcbiAqIC0gVGhlIGNkayBzeW50aCBjb21tYW5kIGluIHRoZSBwaXBlbGluZSBpbmNsdWRlcyBhIHN0YWdlIHBhcmFtLiBXaGVuIHRoZSBwaXBlbGluZSBydW5zLCB0aGUgc3RhZ2UgcGFyYW0gaXMgYXZhaWxhYmxlIGluIG91ciBDREsgY29kZS5cclxuICogZS5nLiBXaGVuIHRoZSBtYWluIGJyYW5jaCBpcyB1cGRhdGVkLCBpdCB0cmlnZ2VycyB0aGUgcHJvZCBwaXBlbGluZSB0byBzeW50aCBhbmQgZGVwbG95IENESyBjaGFuZ2VzIHdpdGggc3RhZ2UgcGFyYW0gPSAncHJvZCcuIFRoaXMgYWxsb3dzIGRldmVsb3BlcnMgdG8gd3JpdGUgY29uZGl0aW9uYWwgQ0RLIGNvZGUgZS5nLiBpZiAoc3RhdHVzID09PSAncHJvZCcpLlxyXG4gKiAtIEEgQ0RLIHBpcGVsaW5lIGlzIGNvbm5lY3RlZCB0byBvbmUgR2l0SHViIGJyYW5jaCAoYW5kIGxpc3RlbnMgdG8gdGhhdCBicmFuY2ggZm9yIHVwZGF0ZXMpLlxyXG4gKlxyXG4gKiBEZXBsb3ltZW50cyBzdXBwb3J0ZWQ6XHJcbiAqIC0gTWFudWFsIENESyBQaXBlbGluZSBzdGFjayBkZXBsb3ltZW50IHRvIENJQ0QgdGVzdCBhbmQgcHJvZCBlbnZpcm9ubWVudHMuXHJcbiAqIC0gR2l0SHViIHRyaWdnZXJlZCBkZXBsb3ltZW50cyBhY3Jvc3MgYWxsIGJyYW5jaGVzIGFuZCBhbGwgQ0lDRCBzdGFnZSBicmFuY2hlcyBlLmcuIChwcm9kICYgdGVzdC1wcm9kLCB0ZXN0ICYgdGVzdC10ZXN0LCBzYW5kYm94MSAmIHRlc3Qtc2FuZGJveDEpLlxyXG4gKiAtIE1hbnVhbCBDREsgc3RhY2sgZGVwbG95cyAodG8gYW55IGVudikuIGUuZy4gZGVwbG95IHN0YWNrIHRvIHNhbmRib3gxLCBkZXBsb3kgc3RhY2sgdG8gdGVzdCwgZGVwbG95IHN0YWNrIHRvIHByb2QuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQ2RrUGlwZWxpbmUgZXh0ZW5kcyBDb25zdHJ1Y3Qge1xyXG5cclxuICAgIHB1YmxpYyBlbnZpcm9ubWVudFBpcGVsaW5lczogSUVudmlyb25tZW50UGlwZWxpbmVbXSA9IFtdO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHNjb3BlOiBDb25zdHJ1Y3QsIGlkOiBzdHJpbmcsIHByb3BzOiBJQ2RrUGlwZWxpbmVQcm9wcykge1xyXG4gICAgICAgIHN1cGVyKHNjb3BlLCBpZCk7XHJcblxyXG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IG5ldyBDb25maWcodGhpcy5ub2RlKTtcclxuICAgICAgICBjb25zdCBjb21tYW5kcyA9IFsnbnBtIGluc3RhbGwnLCAnbnBtIC1nIGluc3RhbGwgdHlwZXNjcmlwdCcsICducG0gaW5zdGFsbCAtZyBueCcsICdueCBidWlsZCBjZGsnLCAnbnggc3ludGggY2RrIC0tYXJncz1cIi0tcXVpZXQgLS1jb250ZXh0IHN0YWdlPSRTVEFHRVwiJ107IC8vIEFXUyBkb2NzIGV4YW1wbGUgY29tbWFuZHM6IFsnbnBtIGNpJywgJ25wbSBydW4gYnVpbGQnLCAnbnB4IGNkayBzeW50aCddXHJcbiAgICAgICAgY29uc3QgcHJpbWFyeU91dHB1dERpcmVjdG9yeSA9ICdhcHBzL2Nkay9jZGsub3V0JztcclxuXHJcbiAgICAgICAgY29uc3Qgc3RhZ2VzID0gbmV3IE1hcChPYmplY3QuZW50cmllcyhjb25maWcuc3RhZ2VzKCkhKSk7XHJcbiAgICAgICAgY29uc3QgYnJhbmNoU3RhZ2VzID0gbmV3IE1hcChbLi4uc3RhZ2VzXS5maWx0ZXIoKFtfLCB2XSkgPT4gdi5icmFuY2ggJiYgIXYuYnJhbmNoLnN0YXJ0c1dpdGgoJygnKSAmJiAhdi5icmFuY2guZW5kc1dpdGgoJyknKSkpO1xyXG4gICAgICAgIGNvbnN0IGJyYW5jaFJlZ2V4U3RhZ2VzID0gbmV3IE1hcChbLi4uc3RhZ2VzXS5maWx0ZXIoKFtfLCB2XSkgPT4gdi5icmFuY2ggJiYgdi5icmFuY2guc3RhcnRzV2l0aCgnKCcpICYmIHYuYnJhbmNoLmVuZHNXaXRoKCcpJykpKTtcclxuXHJcbiAgICAgICAgLy8gRm9yIHN0YXRpYyBicmFuY2hlcyBlLmcuIG1haW4sIHRlc3QuXHJcbiAgICAgICAgZm9yIChjb25zdCBbc3RhZ2UsIHN0YWdlVmFsdWVdIG9mIGJyYW5jaFN0YWdlcy5lbnRyaWVzKCkpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIElmIENJQ0QgcHJvZCBwaXBlbGluZXMgdGhlbiB1c2UgYnJhbmNoIG5hbWVzIGluIGNvbmZpZy4gRWxzZSBDSUNEIHN0YWdlIGlzIHRlc3Qgb3Igb3RoZXIgc28gdXNlIHN0YWdlK2JyYW5jaCBlLmcuIHRlc3QtcHJvZCwgdGVzdC10ZXN0XHJcbiAgICAgICAgICAgIGNvbnN0IGJyYW5jaCA9IChwcm9wcy5zdGFnZSA9PT0gJ3Byb2QnKSA/IHN0YWdlVmFsdWUuYnJhbmNoIDogYCR7cHJvcHMuc3RhZ2V9LSR7c3RhZ2VWYWx1ZS5icmFuY2h9YDtcclxuXHJcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBhIHN0YW5kYXJkIGNkayBwaXBlbGluZSBmb3Igc3RhdGljIGJyYW5jaGVzLiBQZXJmb3JtYW5jZSBpcyBiZXR0ZXIgKG5vIFMzIGZpbGUgY29weSByZXF1aXJlZCkuXHJcbiAgICAgICAgICAgIGNvbnN0IHBpcGVsaW5lID0gbmV3IHBpcGVsaW5lcy5Db2RlUGlwZWxpbmUodGhpcywgYENka0NvZGVQaXBlbGluZSR7Y2hhbmdlQ2FzZS5wYXNjYWxDYXNlKGJyYW5jaCl9YCwge1xyXG4gICAgICAgICAgICAgICAgcGlwZWxpbmVOYW1lOiBgY2RrLXBpcGVsaW5lLSR7YnJhbmNofWAsXHJcbiAgICAgICAgICAgICAgICBjcm9zc0FjY291bnRLZXlzOiB0cnVlLCAvLyBSZXF1aXJlZCBmb3IgY3Jvc3MgYWNjb3VudCBkZXBsb3lzLlxyXG4gICAgICAgICAgICAgICAgc3ludGg6IG5ldyBwaXBlbGluZXMuU2hlbGxTdGVwKCdTeW50aCcsIHtcclxuICAgICAgICAgICAgICAgICAgICBlbnY6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgU1RBR0U6IGAke3Byb3BzLnN0YWdlfWAgLy8gVGhlIENJQ0Qgc3RhZ2U6IHR5cGljYWxseSB0ZXN0IG9yIHByb2QuXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBBbGxvdyBHaXRIdWIgdG9rZW4gb3B0aW9uLlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlucHV0OiBwaXBlbGluZXMuQ29kZVBpcGVsaW5lU291cmNlLmdpdEh1YihcclxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgYCR7cHJvcHMuZ2l0SHViLm93bmVyfS8ke3Byb3BzLmdpdEh1Yi5yZXBvfWAsXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgIGJyYW5jaCxcclxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgeyBhdXRoZW50aWNhdGlvbjogcHJvcHMuZ2l0SHViLnRva2VuIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyApLFxyXG4gICAgICAgICAgICAgICAgICAgIGlucHV0OiBwaXBlbGluZXMuQ29kZVBpcGVsaW5lU291cmNlLmNvbm5lY3Rpb24oYCR7cHJvcHMuZ2l0SHViLm93bmVyfS8ke3Byb3BzLmdpdEh1Yi5yZXBvfWAsIGJyYW5jaCwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uQXJuOiBwcm9wcy5naXRIdWIuY29ubmVjdGlvbkFybixcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZUJ1aWxkQ2xvbmVPdXRwdXQ6IHRydWVcclxuICAgICAgICAgICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgICAgICAgICBjb21tYW5kczogcHJvcHMuY29tbWFuZHMgPz8gY29tbWFuZHMsXHJcbiAgICAgICAgICAgICAgICAgICAgcHJpbWFyeU91dHB1dERpcmVjdG9yeVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmVudmlyb25tZW50UGlwZWxpbmVzLnB1c2goeyBicmFuY2gsIHBpcGVsaW5lU3RhZ2U6IHN0YWdlLCBwaXBlbGluZSB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChicmFuY2hSZWdleFN0YWdlcy5zaXplKSB7XHJcbiAgICAgICAgICAgIC8vIENyZWF0ZSBidWNrZXQgdG8gc2F2ZSBnaXRodWIgc2FuZGJveCBmZWF0dXJlIGJyYW5jaCBmaWxlcyAoYXMgemlwKS5cclxuICAgICAgICAgICAgY29uc3QgYnVja2V0ID0gbmV3IHMzLkJ1Y2tldCh0aGlzLCBgJHtjb25maWcub3JnYW5pemF0aW9uTmFtZVBhc2NhbENhc2UoKX1DZGtQaXBlbGluZUJyYW5jaGAsIHtcclxuICAgICAgICAgICAgICAgIC8vIFZlcnNpb24gbXVzdCBiZSB0cnVlIHRvIHVzZSBhcyBDb2RlUGlwZWxpbmUgc291cmNlLlxyXG4gICAgICAgICAgICAgICAgdmVyc2lvbmVkOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgcHVibGljUmVhZEFjY2VzczogZmFsc2UsIC8vIFRPRE86IElzIHRoaXMgbmVlZGVkP1xyXG4gICAgICAgICAgICAgICAgYmxvY2tQdWJsaWNBY2Nlc3M6IHMzLkJsb2NrUHVibGljQWNjZXNzLkJMT0NLX0FMTCxcclxuICAgICAgICAgICAgICAgIGVuZm9yY2VTU0w6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAvLyBEZXN0cm95IGJ1Y2tldCBvbiBzdGFjayBkZWxldGUuIEJ1Y2tldCBjb250YWlucyB0ZW1wb3JhcnkgY29weSBvZiBzb3VyY2UgY29udHJvbCBmaWxlcyBvbmx5LlxyXG4gICAgICAgICAgICAgICAgcmVtb3ZhbFBvbGljeTogY2RrLlJlbW92YWxQb2xpY3kuREVTVFJPWSxcclxuICAgICAgICAgICAgICAgIC8vIERlbGV0ZSBhbGwgYnVja2V0IG9iamVjdHMgb24gYnVja2V0L3N0YWNrIGRlc3Ryb3kuXHJcbiAgICAgICAgICAgICAgICBhdXRvRGVsZXRlT2JqZWN0czogdHJ1ZVxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgW3N0YWdlLCBzdGFnZVZhbHVlXSBvZiBicmFuY2hSZWdleFN0YWdlcy5lbnRyaWVzKCkpIHtcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBicmFuY2hTdWJzdHJpbmcgPSBzdGFnZVZhbHVlLmJyYW5jaC5zbGljZSgxLCAtMSk7IC8vIFJlbW92ZSBmaXJzdCBhbmQgbGFzdCBjaGFycyBpLmUuIHBhcmVudGhlc2lzLlxyXG4gICAgICAgICAgICAgICAgY29uc3QgYnJhbmNoRmlsZU5hbWUgPSBgYnJhbmNoLSR7cHJvcHMuc3RhZ2V9LSR7YnJhbmNoU3Vic3RyaW5nfS56aXBgO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhZ2VQYXNjYWxDYXNlID0gY2hhbmdlQ2FzZS5wYXNjYWxDYXNlKHN0YWdlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBJZiBDSUNEIHN0YWdlIGlzIHByb2QsIG1hdGNoIGJyYW5jaCBzdWJzdHJpbmcgc29tZXdoZXJlIGluIGJyYW5jaCBuYW1lLiBFbHNlIENJQ0Qgc3RhZ2UgaXMgJ3Rlc3QnIChvciBvdGhlcikgc28gbWF0Y2ggJ3Rlc3QnIHNvbWV3aGVyZSBpbiBicmFuY2ggbmFtZS5cclxuICAgICAgICAgICAgICAgIC8vIGUuZy4gcHJvZDogKHNhbmRib3gxKSBpbiBjb25maWcgd2lsbCBtYXRjaCBicmFuY2hlczogc2FuZGJveDEsIG15LXNhbmRib3gxLWZlYXR1cmUsIG15LXNhbmRib3gxLWZlYXR1cmUyXHJcbiAgICAgICAgICAgICAgICAvLyBlLmcuIHRlc3Q6IGUuZy4gKHNhbmRib3gxKSBpbiBjb25maWcgd2lsbCBtYXRjaDogdGVzdHNhbmRib3gxLCBzYW5kYm94MXRlc3QsIHRlc3Qtc2FuZGJveDEsIHNhbmRib3gxLXRlc3QsIGV0Yy5cclxuICAgICAgICAgICAgICAgIGNvbnN0IGJyYW5jaFJlZ2V4ID0gKHByb3BzLnN0YWdlID09PSAncHJvZCcpID8gYCgke2JyYW5jaFN1YnN0cmluZ30pYCA6IGAoPz0uKiR7YnJhbmNoU3Vic3RyaW5nfSkoPz0uKnRlc3QpYDtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgZ2l0aHViIHNvdXJjZSAoZS5nLiBzYW5kYm94IGZlYXR1cmUgYnJhbmNoKS5cclxuICAgICAgICAgICAgICAgIGNvbnN0IGdpdEh1YkJyYW5jaFNvdXJjZSA9IGNvZGVidWlsZFxyXG4gICAgICAgICAgICAgICAgICAgIC5Tb3VyY2UuZ2l0SHViKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3duZXI6IHByb3BzLmdpdEh1Yi5vd25lcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVwbzogcHJvcHMuZ2l0SHViLnJlcG8sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZldGNoU3VibW9kdWxlczogdHJ1ZSwgLy8gRm9yIGFsbCBHaXQgc291cmNlcywgeW91IGNhbiBmZXRjaCBzdWJtb2R1bGVzIHdoaWxlIGNsb2luZyBnaXQgcmVwby5cclxuICAgICAgICAgICAgICAgICAgICAgICAgd2ViaG9vazogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2ViaG9va0ZpbHRlcnM6IFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVidWlsZC5GaWx0ZXJHcm91cFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5pbkV2ZW50T2YoY29kZWJ1aWxkLkV2ZW50QWN0aW9uLlBVU0gpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFuZEJyYW5jaElzTm90KCdtYWluJykgLy8gRm9yIGFkZGl0aW9uYWwgcHJvdGVjdGlvbiBvbmx5LlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hbmRCcmFuY2hJcyhgLioke2JyYW5jaFJlZ2V4fS4qYCkgLy8gZS5nLiBhdXRob3Itc2FuZGJveDEtbXktZmVhdHVyZSwgdGVzdCA9IGF1dGhvci10ZXN0LXNhbmRib3gxLW15LWZlYXR1cmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgXVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBidWlsZCBwcm9qZWN0ICh0byBjb3B5IGZlYXR1cmUgYnJhbmNoIGZpbGVzIHRvIFMzIG9uIGdpdGh1YiBwdXNoKS5cclxuICAgICAgICAgICAgICAgIGNvbnN0IGdpdGh1YkNvZGVCdWlsZFByb2plY3QgPSBuZXcgY29kZWJ1aWxkLlByb2plY3QodGhpcywgYEdpdGh1YkNvZGVCdWlsZFByb2plY3Qke3N0YWdlUGFzY2FsQ2FzZX1gLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvamVjdE5hbWU6IGBjb3B5LWdpdGh1Yi0ke3Byb3BzLnN0YWdlfS0ke2JyYW5jaFN1YnN0cmluZ30tdG8tczNgLFxyXG4gICAgICAgICAgICAgICAgICAgIGJ1aWxkU3BlYzogY29kZWJ1aWxkLkJ1aWxkU3BlYy5mcm9tT2JqZWN0KHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmVyc2lvbjogMC4yLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcnRpZmFjdHM6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVzOiAnKiovKidcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZTogZ2l0SHViQnJhbmNoU291cmNlLFxyXG4gICAgICAgICAgICAgICAgICAgIGFydGlmYWN0czogY29kZWJ1aWxkLkFydGlmYWN0cy5zMyh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGJyYW5jaEZpbGVOYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWNrZXQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1ZGVCdWlsZElkOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFja2FnZVppcDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWRlbnRpZmllcjogJ0dpdGh1YkFydGlmYWN0J1xyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIC8vIENvZGVCdWlsZCBwcm9qZWN0IHJlcXVpcmVzIHBlcm1pc3Npb25zIHRvIFMzIGJ1Y2tldCBvYmplY3RzLlxyXG4gICAgICAgICAgICAgICAgZ2l0aHViQ29kZUJ1aWxkUHJvamVjdC5hZGRUb1JvbGVQb2xpY3kobmV3IGlhbS5Qb2xpY3lTdGF0ZW1lbnQoe1xyXG4gICAgICAgICAgICAgICAgICAgIGVmZmVjdDogaWFtLkVmZmVjdC5BTExPVyxcclxuICAgICAgICAgICAgICAgICAgICBhY3Rpb25zOiBbJ3MzOkxpc3RCdWNrZXQnLCAnczM6R2V0T2JqZWN0JywgJ3MzOlB1dE9iamVjdCcsICdzMzpEZWxldGVPYmplY3QnXSxcclxuICAgICAgICAgICAgICAgICAgICByZXNvdXJjZXM6IFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVja2V0LmJ1Y2tldEFybixcclxuICAgICAgICAgICAgICAgICAgICAgICAgYCR7YnVja2V0LmJ1Y2tldEFybn0vKmBcclxuICAgICAgICAgICAgICAgICAgICBdXHJcbiAgICAgICAgICAgICAgICB9KSk7XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3QgcGlwZWxpbmUgPSBuZXcgcGlwZWxpbmVzLkNvZGVQaXBlbGluZSh0aGlzLCBgQ2RrQ29kZVBpcGVsaW5lJHtzdGFnZVBhc2NhbENhc2V9YCwge1xyXG4gICAgICAgICAgICAgICAgICAgIHBpcGVsaW5lTmFtZTogYGNkay1waXBlbGluZS0ke3Byb3BzLnN0YWdlfS0ke2JyYW5jaFN1YnN0cmluZ31gLFxyXG4gICAgICAgICAgICAgICAgICAgIGNyb3NzQWNjb3VudEtleXM6IHRydWUsIC8vIFJlcXVpcmVkIGZvciBjcm9zcyBhY2NvdW50IGRlcGxveXMuXHJcbiAgICAgICAgICAgICAgICAgICAgc3ludGg6IG5ldyBwaXBlbGluZXMuU2hlbGxTdGVwKCdTeW50aCcsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW52OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBTVEFHRTogcHJvcHMuc3RhZ2UgLy8gVGhlIENJQ0Qgc3RhZ2UgdHlwaWNhbGx5OiB0ZXN0IG9yIHByb2QuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0OiBwaXBlbGluZXMuQ29kZVBpcGVsaW5lU291cmNlLnMzKGJ1Y2tldCwgYnJhbmNoRmlsZU5hbWUpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tYW5kczogcHJvcHMuY29tbWFuZHMgPz8gY29tbWFuZHMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaW1hcnlPdXRwdXREaXJlY3RvcnlcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVGhlIGJyYW5jaCBuYW1lIGlzIGFjdHVhbGx5IGEgcmVnZXguIEJ1dCBzcGVjaWZ5IGEgYnJhbmNoIG5hZW0gdGhhdCdzIGVhc2llciB0byB3b3JrIHdpdGggKGFuZCBzdGlsbCBtYXRjaGVzIHRoZSByZWdleCkgZS5nLiB0ZXN0LXNhbmRib3gxLlxyXG4gICAgICAgICAgICAgICAgY29uc3QgYnJhbmNoID0gKHByb3BzLnN0YWdlID09PSAncHJvZCcpID8gYnJhbmNoU3Vic3RyaW5nIDogYCR7cHJvcHMuc3RhZ2V9LSR7YnJhbmNoU3Vic3RyaW5nfWA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVudmlyb25tZW50UGlwZWxpbmVzLnB1c2goeyBicmFuY2gsIHBpcGVsaW5lU3RhZ2U6IHN0YWdlLCBwaXBlbGluZSB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4iXX0=