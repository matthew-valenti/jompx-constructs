"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DefaultRequestMappingTemplate = exports.AppSyncLambdaDefaultProps = void 0;
const cdk = require("aws-cdk-lib");
const lambda = require("aws-cdk-lib/aws-lambda");
exports.AppSyncLambdaDefaultProps = {
    runtime: lambda.Runtime.NODEJS_14_X,
    timeout: cdk.Duration.seconds(5),
    bundling: {
        minify: true,
        sourceMap: true
    }
};
// AppSync VTL snippet to pass event params to Lambda resolver: https://docs.aws.amazon.com/appsync/latest/devguide/resolver-mapping-template-reference-programming-guide.html
// With no VTL, the Lambda event contains all properties below. However, selectionSetList is a child property of info.
// Thru trial and error there doesn't appear to be a way to add selectionSetList as a child property.
// We need VTL because this is the only known way to pass variables directly into the Lambda.
// However, when we specify any VTL we must specify all VTL. Adding data to the stash property results in an empty Lambda event.
// Stash variables can be added by appending additional VTL above this payload statement. i.e. $util.qr($ctx.stash.put("key", "value"))
// This VTL invokes a payload property which simply returns an object with properties (taken from the AppSync $context variable).
// Caution: payload should mimic a standard Lambda resolver (with no VTL). This object might change in the future.
// In theory, we could use a Lambda function instead of VTL but this should be much faster than invoking another Lambda.
exports.DefaultRequestMappingTemplate = `{
    "version" : "2018-05-29",
    "operation": "Invoke",
    "payload": {
        "arguments": $utils.toJson($context.arguments),
        "identity": $utils.toJson($context.identity),
        "source": $utils.toJson($context.source),
        "request": $utils.toJson($context.request),
        "prev": $utils.toJson($context.prev),
        "info": $utils.toJson($context.info),
        "stash": $utils.toJson($context.stash),
        "selectionSetList": $utils.toJson($context.info.selectionSetList)
    }
}`;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXBwLXN5bmMudHlwZXMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvYXBwLXN5bmMvYXBwLXN5bmMudHlwZXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBRUEsbUNBQW1DO0FBQ25DLGlEQUFpRDtBQStCcEMsUUFBQSx5QkFBeUIsR0FBOEM7SUFDaEYsT0FBTyxFQUFFLE1BQU0sQ0FBQyxPQUFPLENBQUMsV0FBVztJQUNuQyxPQUFPLEVBQUUsR0FBRyxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDO0lBQ2hDLFFBQVEsRUFBRTtRQUNOLE1BQU0sRUFBRSxJQUFJO1FBQ1osU0FBUyxFQUFFLElBQUk7S0FDbEI7Q0FDSixDQUFDO0FBd0dGLDhLQUE4SztBQUM5SyxzSEFBc0g7QUFDdEgscUdBQXFHO0FBQ3JHLDZGQUE2RjtBQUM3RixnSUFBZ0k7QUFDaEksdUlBQXVJO0FBQ3ZJLGlJQUFpSTtBQUNqSSxrSEFBa0g7QUFDbEgsd0hBQXdIO0FBQzNHLFFBQUEsNkJBQTZCLEdBQUc7Ozs7Ozs7Ozs7Ozs7RUFhM0MsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tZXh0cmFuZW91cy1kZXBlbmRlbmNpZXNcclxuaW1wb3J0ICogYXMgYXBwc3luYyBmcm9tICdAYXdzLWNkay9hd3MtYXBwc3luYy1hbHBoYSc7XHJcbmltcG9ydCAqIGFzIGNkayBmcm9tICdhd3MtY2RrLWxpYic7XHJcbmltcG9ydCAqIGFzIGxhbWJkYSBmcm9tICdhd3MtY2RrLWxpYi9hd3MtbGFtYmRhJztcclxuaW1wb3J0IHR5cGUgeyBBcHBTeW5jUmVzb2x2ZXJFdmVudCB9IGZyb20gJ2F3cy1sYW1iZGEnO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBJRGF0YVNvdXJjZSB7XHJcbiAgICBba2V5OiBzdHJpbmddOiBhcHBzeW5jLkxhbWJkYURhdGFTb3VyY2U7XHJcbn1cclxuXHJcbi8vIGV4cG9ydCBpbnRlcmZhY2UgSVNjaGVtYVR5cGVzIHtcclxuLy8gICAgIFtrZXk6IHN0cmluZ106IElTY2hlbWFJbnB1dFR5cGU7XHJcbi8vIH1cclxuLy8gZXhwb3J0IHR5cGUgSVNjaGVtYUlucHV0VHlwZSA9IEludGVyZmFjZVR5cGUgfCBPYmplY3RUeXBlIHwgSW5wdXRUeXBlO1xyXG5cclxuLy8gVHlwZXNjcmlwdCBpbnN0YW5jZW9mIHByb2R1Y2VzIHVucHJlZGljdGFibGUgcmVzdWx0cyBkdWUgdG8gdXNlIG9mIGV4dGVuZHMgKGUuZy4gbXlPYmplY3RUeXBlIGluc3RhbmNlb2YgSW50ZXJmYWNlVHlwZSByZXR1cm5zIHRydWUpLiBVc2UgZXhwbGljaXQgdHlwZXMgaW5zdGVhZC5cclxuZXhwb3J0IGludGVyZmFjZSBJU2NoZW1hVHlwZXMge1xyXG4gICAgZW51bVR5cGVzOiB7XHJcbiAgICAgICAgW2tleTogc3RyaW5nXTogYXBwc3luYy5FbnVtVHlwZTtcclxuICAgIH07XHJcbiAgICBpbnB1dFR5cGVzOiB7XHJcbiAgICAgICAgW2tleTogc3RyaW5nXTogYXBwc3luYy5JbnB1dFR5cGU7XHJcbiAgICB9O1xyXG4gICAgaW50ZXJmYWNlVHlwZXM6IHtcclxuICAgICAgICBba2V5OiBzdHJpbmddOiBhcHBzeW5jLkludGVyZmFjZVR5cGU7XHJcbiAgICB9O1xyXG4gICAgb2JqZWN0VHlwZXM6IHtcclxuICAgICAgICBba2V5OiBzdHJpbmddOiBhcHBzeW5jLk9iamVjdFR5cGU7XHJcbiAgICB9O1xyXG4gICAgdW5pb25UeXBlczoge1xyXG4gICAgICAgIFtrZXk6IHN0cmluZ106IGFwcHN5bmMuVW5pb25UeXBlO1xyXG4gICAgfTtcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IEFwcFN5bmNMYW1iZGFEZWZhdWx0UHJvcHM6IGNkay5hd3NfbGFtYmRhX25vZGVqcy5Ob2RlanNGdW5jdGlvblByb3BzID0ge1xyXG4gICAgcnVudGltZTogbGFtYmRhLlJ1bnRpbWUuTk9ERUpTXzE0X1gsXHJcbiAgICB0aW1lb3V0OiBjZGsuRHVyYXRpb24uc2Vjb25kcyg1KSxcclxuICAgIGJ1bmRsaW5nOiB7XHJcbiAgICAgICAgbWluaWZ5OiB0cnVlLFxyXG4gICAgICAgIHNvdXJjZU1hcDogdHJ1ZVxyXG4gICAgfVxyXG59O1xyXG5cclxuLypcclxuZXhwb3J0IGludGVyZmFjZSBBcHBTeW5jUmVzb2x2ZXJFdmVudDxUQXJndW1lbnRzLCBUU291cmNlID0gUmVjb3JkPHN0cmluZywgYW55PiB8IG51bGw+IHtcclxuICAgIGFyZ3VtZW50czogVEFyZ3VtZW50cztcclxuICAgIGlkZW50aXR5PzogQXBwU3luY0lkZW50aXR5O1xyXG4gICAgc291cmNlOiBUU291cmNlO1xyXG4gICAgcmVxdWVzdDoge1xyXG4gICAgICAgIGhlYWRlcnM6IEFwcFN5bmNSZXNvbHZlckV2ZW50SGVhZGVycztcclxuICAgIH07XHJcbiAgICBpbmZvOiB7XHJcbiAgICAgICAgc2VsZWN0aW9uU2V0TGlzdDogc3RyaW5nW107XHJcbiAgICAgICAgc2VsZWN0aW9uU2V0R3JhcGhRTDogc3RyaW5nO1xyXG4gICAgICAgIHBhcmVudFR5cGVOYW1lOiBzdHJpbmc7XHJcbiAgICAgICAgZmllbGROYW1lOiBzdHJpbmc7XHJcbiAgICAgICAgdmFyaWFibGVzOiB7IFtrZXk6IHN0cmluZ106IGFueSB9O1xyXG4gICAgfTtcclxuICAgIHByZXY6IHsgcmVzdWx0OiB7IFtrZXk6IHN0cmluZ106IGFueSB9IH0gfCBudWxsO1xyXG4gICAgc3Rhc2g6IHsgW2tleTogc3RyaW5nXTogYW55IH07XHJcbn1cclxuKi9cclxuXHJcbmV4cG9ydCB0eXBlIElBcHBTeW5jUmVzb2x2ZXJFdmVudCA9IEFwcFN5bmNSZXNvbHZlckV2ZW50PGFueT5cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgSUFwcFN5bmNPcGVyYXRpb25BcmdzIHtcclxuICAgIFtrZXk6IHN0cmluZ106IGFwcHN5bmMuR3JhcGhxbFR5cGU7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgSUFwcFN5bmNDb25uZWN0aW9uIHtcclxuICAgIGVkZ2VzPzogW3tcclxuICAgICAgICBjdXJzb3I/OiBzdHJpbmc7XHJcbiAgICAgICAgbm9kZTogYW55O1xyXG4gICAgfV07XHJcbiAgICBwYWdlSW5mbzogSUFwcFN5bmNQYWdlSW5mb09mZnNldCB8IElBcHBTeW5jUGFnZUluZm9DdXJzb3I7XHJcbiAgICB0b3RhbENvdW50PzogbnVtYmVyO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIElBcHBTeW5jUGFnZUluZm9PZmZzZXQge1xyXG4gICAgc2tpcDogbnVtYmVyO1xyXG4gICAgbGltaXQ6IG51bWJlcjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBJQXBwU3luY1BhZ2VJbmZvQ3Vyc29yIHtcclxuICAgIGhhc1ByZXZpb3VzUGFnZTogYm9vbGVhbjtcclxuICAgIGhhc05leHRQYWdlOiBib29sZWFuO1xyXG4gICAgc3RhcnRDdXJzb3I6IHN0cmluZztcclxuICAgIGVuZEN1cnNvcjogc3RyaW5nO1xyXG59XHJcblxyXG4vLyBMaXN0IG9mIG5lc3RlZCBJRmllbGRzLlxyXG5leHBvcnQgaW50ZXJmYWNlIEFwcFN5bmNJRmllbGRzIHtcclxuICAgIFtrZXk6IHN0cmluZ106IEFwcFN5bmNJRmllbGRzIHwgYXBwc3luYy5JRmllbGQ7XHJcbn1cclxuXHJcbi8qXHJcbi8vIEV4YW1wbGUgSUFNIGlkZW50aXR5IGZyb20gQXBwU3luYyBldmVudC5cclxuaWRlbnRpdHk6IHtcclxuICAgIGFjY291bnRJZDogJzA2NjIwOTY1MzU2NycsXHJcbiAgICBjb2duaXRvSWRlbnRpdHlBdXRoUHJvdmlkZXI6IG51bGwsXHJcbiAgICBjb2duaXRvSWRlbnRpdHlBdXRoVHlwZTogbnVsbCxcclxuICAgIGNvZ25pdG9JZGVudGl0eUlkOiBudWxsLFxyXG4gICAgY29nbml0b0lkZW50aXR5UG9vbElkOiBudWxsLFxyXG4gICAgc291cmNlSXA6IFsgJzU0LjI0MC4yMzAuMjQ0JyBdLFxyXG4gICAgdXNlckFybjogJ2Fybjphd3M6c3RzOjowNjYyMDk2NTM1Njc6YXNzdW1lZC1yb2xlL0FXU1Jlc2VydmVkU1NPX0FkbWluaXN0cmF0b3JBY2Nlc3NfOTVhY2RiYzgxYzg0NGM1Ni9hZG1pbicsXHJcbiAgICB1c2VybmFtZTogJ0FST0FRNjJUSEVNNzZYUTZUT1VQSzphZG1pbidcclxufVxyXG4vLyBFeGFtcGxlIENvZ25pdG8gY2xhaW0gZnJvbSBBcHBTeW5jIGV2ZW50LlxyXG5pZGVudGl0eToge1xyXG4gICAgY2xhaW1zOiB7XHJcbiAgICAgIHN1YjogJzQyODUzMmUzLTRlYjYtNDg4OS1iYTk0LTcyNmZmZTBmMGQ4NycsXHJcbiAgICAgICdjb2duaXRvOmdyb3Vwcyc6IFtBcnJheV0sXHJcbiAgICAgIGVtYWlsX3ZlcmlmaWVkOiB0cnVlLFxyXG4gICAgICBpc3M6ICdodHRwczovL2NvZ25pdG8taWRwLnVzLXdlc3QtMi5hbWF6b25hd3MuY29tL3VzLXdlc3QtMl8xZGVTdGdYamMnLFxyXG4gICAgICAnY29nbml0bzp1c2VybmFtZSc6ICc0Mjg1MzJlMy00ZWI2LTQ4ODktYmE5NC03MjZmZmUwZjBkODcnLFxyXG4gICAgICBvcmlnaW5fanRpOiAnNWNjOTkwNTAtMDhlMS00ZjUwLThjNzctMDc2MDcyYjg3MWIwJyxcclxuICAgICAgYXVkOiAnN2pqa2NrMzVqcW4zZDljMTNrMWh0M2ZpYmsnLFxyXG4gICAgICBldmVudF9pZDogJ2VmZDBhNWQ5LTc4NWMtNGI0ZS04YmQ5LTUyMGUzNWExZmM2MycsXHJcbiAgICAgIHRva2VuX3VzZTogJ2lkJyxcclxuICAgICAgYXV0aF90aW1lOiAxNjUyNjYxMDkxLFxyXG4gICAgICBleHA6IDE2NTI2NjQ2OTEsXHJcbiAgICAgIGlhdDogMTY1MjY2MTA5MSxcclxuICAgICAganRpOiAnYjFmNzFlNGItMWZhMi00YzFjLWI0ODMtZmM5MjNhY2FmZDM0JyxcclxuICAgICAgZW1haWw6ICdtYXR0aGV3QGpvbXB4LmNvbSdcclxuICAgIH0sXHJcbiAgICBkZWZhdWx0QXV0aFN0cmF0ZWd5OiAnREVOWScsXHJcbiAgICBncm91cHM6IFsgJ2FkbWluJyBdLFxyXG4gICAgaXNzdWVyOiAnaHR0cHM6Ly9jb2duaXRvLWlkcC51cy13ZXN0LTIuYW1hem9uYXdzLmNvbS91cy13ZXN0LTJfMWRlU3RnWGpjJyxcclxuICAgIHNvdXJjZUlwOiBbICc2Ny41Mi4xNjAuMjE0JyBdLFxyXG4gICAgc3ViOiAnNDI4NTMyZTMtNGViNi00ODg5LWJhOTQtNzI2ZmZlMGYwZDg3JyxcclxuICAgIHVzZXJuYW1lOiAnNDI4NTMyZTMtNGViNi00ODg5LWJhOTQtNzI2ZmZlMGYwZDg3J1xyXG59XHJcbiovXHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIElBcHBTeW5jTWV0aG9kUHJvcHNDb2duaXRvIHtcclxuICAgIHN1Yjogc3RyaW5nO1xyXG4gICAgZW1haWw6IHN0cmluZztcclxuICAgIGdyb3Vwczogc3RyaW5nW107XHJcbiAgICBhdXRob3JpemF0aW9uOiBzdHJpbmc7XHJcbn1cclxuZXhwb3J0IGludGVyZmFjZSBJQXBwU3luY01ldGhvZFByb3BzIHtcclxuICAgIGNvZ25pdG8/OiBJQXBwU3luY01ldGhvZFByb3BzQ29nbml0bztcclxuICAgIGV2ZW50OiBhbnk7XHJcbn1cclxuXHJcbi8vIEFwcFN5bmMgVlRMIHNuaXBwZXQgdG8gcGFzcyBldmVudCBwYXJhbXMgdG8gTGFtYmRhIHJlc29sdmVyOiBodHRwczovL2RvY3MuYXdzLmFtYXpvbi5jb20vYXBwc3luYy9sYXRlc3QvZGV2Z3VpZGUvcmVzb2x2ZXItbWFwcGluZy10ZW1wbGF0ZS1yZWZlcmVuY2UtcHJvZ3JhbW1pbmctZ3VpZGUuaHRtbFxyXG4vLyBXaXRoIG5vIFZUTCwgdGhlIExhbWJkYSBldmVudCBjb250YWlucyBhbGwgcHJvcGVydGllcyBiZWxvdy4gSG93ZXZlciwgc2VsZWN0aW9uU2V0TGlzdCBpcyBhIGNoaWxkIHByb3BlcnR5IG9mIGluZm8uXHJcbi8vIFRocnUgdHJpYWwgYW5kIGVycm9yIHRoZXJlIGRvZXNuJ3QgYXBwZWFyIHRvIGJlIGEgd2F5IHRvIGFkZCBzZWxlY3Rpb25TZXRMaXN0IGFzIGEgY2hpbGQgcHJvcGVydHkuXHJcbi8vIFdlIG5lZWQgVlRMIGJlY2F1c2UgdGhpcyBpcyB0aGUgb25seSBrbm93biB3YXkgdG8gcGFzcyB2YXJpYWJsZXMgZGlyZWN0bHkgaW50byB0aGUgTGFtYmRhLlxyXG4vLyBIb3dldmVyLCB3aGVuIHdlIHNwZWNpZnkgYW55IFZUTCB3ZSBtdXN0IHNwZWNpZnkgYWxsIFZUTC4gQWRkaW5nIGRhdGEgdG8gdGhlIHN0YXNoIHByb3BlcnR5IHJlc3VsdHMgaW4gYW4gZW1wdHkgTGFtYmRhIGV2ZW50LlxyXG4vLyBTdGFzaCB2YXJpYWJsZXMgY2FuIGJlIGFkZGVkIGJ5IGFwcGVuZGluZyBhZGRpdGlvbmFsIFZUTCBhYm92ZSB0aGlzIHBheWxvYWQgc3RhdGVtZW50LiBpLmUuICR1dGlsLnFyKCRjdHguc3Rhc2gucHV0KFwia2V5XCIsIFwidmFsdWVcIikpXHJcbi8vIFRoaXMgVlRMIGludm9rZXMgYSBwYXlsb2FkIHByb3BlcnR5IHdoaWNoIHNpbXBseSByZXR1cm5zIGFuIG9iamVjdCB3aXRoIHByb3BlcnRpZXMgKHRha2VuIGZyb20gdGhlIEFwcFN5bmMgJGNvbnRleHQgdmFyaWFibGUpLlxyXG4vLyBDYXV0aW9uOiBwYXlsb2FkIHNob3VsZCBtaW1pYyBhIHN0YW5kYXJkIExhbWJkYSByZXNvbHZlciAod2l0aCBubyBWVEwpLiBUaGlzIG9iamVjdCBtaWdodCBjaGFuZ2UgaW4gdGhlIGZ1dHVyZS5cclxuLy8gSW4gdGhlb3J5LCB3ZSBjb3VsZCB1c2UgYSBMYW1iZGEgZnVuY3Rpb24gaW5zdGVhZCBvZiBWVEwgYnV0IHRoaXMgc2hvdWxkIGJlIG11Y2ggZmFzdGVyIHRoYW4gaW52b2tpbmcgYW5vdGhlciBMYW1iZGEuXHJcbmV4cG9ydCBjb25zdCBEZWZhdWx0UmVxdWVzdE1hcHBpbmdUZW1wbGF0ZSA9IGB7XHJcbiAgICBcInZlcnNpb25cIiA6IFwiMjAxOC0wNS0yOVwiLFxyXG4gICAgXCJvcGVyYXRpb25cIjogXCJJbnZva2VcIixcclxuICAgIFwicGF5bG9hZFwiOiB7XHJcbiAgICAgICAgXCJhcmd1bWVudHNcIjogJHV0aWxzLnRvSnNvbigkY29udGV4dC5hcmd1bWVudHMpLFxyXG4gICAgICAgIFwiaWRlbnRpdHlcIjogJHV0aWxzLnRvSnNvbigkY29udGV4dC5pZGVudGl0eSksXHJcbiAgICAgICAgXCJzb3VyY2VcIjogJHV0aWxzLnRvSnNvbigkY29udGV4dC5zb3VyY2UpLFxyXG4gICAgICAgIFwicmVxdWVzdFwiOiAkdXRpbHMudG9Kc29uKCRjb250ZXh0LnJlcXVlc3QpLFxyXG4gICAgICAgIFwicHJldlwiOiAkdXRpbHMudG9Kc29uKCRjb250ZXh0LnByZXYpLFxyXG4gICAgICAgIFwiaW5mb1wiOiAkdXRpbHMudG9Kc29uKCRjb250ZXh0LmluZm8pLFxyXG4gICAgICAgIFwic3Rhc2hcIjogJHV0aWxzLnRvSnNvbigkY29udGV4dC5zdGFzaCksXHJcbiAgICAgICAgXCJzZWxlY3Rpb25TZXRMaXN0XCI6ICR1dGlscy50b0pzb24oJGNvbnRleHQuaW5mby5zZWxlY3Rpb25TZXRMaXN0KVxyXG4gICAgfVxyXG59YDtcclxuIl19